#include "wlc.h"
#include "gles2.h"
#include "render.h"

#include "context/egl.h"
#include "context/context.h"
#include "compositor/view.h"
#include "compositor/surface.h"
#include "compositor/buffer.h"
#include "compositor/output.h"
#include "shell/xdg-surface.h"
#include "xwayland/xwm.h"

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <dlfcn.h>

#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>

#include <wayland-server.h>

unsigned char cursor_rgba[];

enum program_type {
   PROGRAM_RGB,
   PROGRAM_RGBA,
   PROGRAM_LAST,
};

enum {
   UNIFORM_WIDTH,
   UNIFORM_HEIGHT,
   UNIFORM_DIM,
   UNIFORM_LAST,
};

enum {
   TEXTURE_BLACK,
   TEXTURE_CURSOR,
   TEXTURE_LAST
};

static const char *uniform_names[UNIFORM_LAST] = {
   "width",
   "height",
   "dim"
};

struct ctx {
   struct wlc_context *context;
   const char *extensions;

   struct ctx_program *program;

   struct ctx_program {
      GLuint obj;
      GLuint uniforms[UNIFORM_LAST];
   } programs[PROGRAM_LAST];

   struct wlc_size resolution;

   GLuint textures[TEXTURE_LAST];

   struct {
      // EGL surfaces
      PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
   } api;
};

struct paint {
   struct wlc_geometry visible;
   float dim;
   enum program_type program;
   bool filter;
};

static struct {
   struct {
      void *handle;

      const GLubyte* (*glGetString)(GLenum);
      void (*glEnable)(GLenum);
      void (*glClear)(GLbitfield);
      void (*glClearColor)(GLfloat, GLfloat, GLfloat, GLfloat);
      void (*glViewport)(GLint, GLint, GLsizei, GLsizei);
      void (*glBlendFunc)(GLenum, GLenum);
      GLuint (*glCreateShader)(GLenum);
      void (*glShaderSource)(GLuint, GLsizei count, const GLchar **string, const GLint *length);
      void (*glCompileShader)(GLuint);
      void (*glGetShaderiv)(GLuint, GLenum, GLint*);
      void (*glGetShaderInfoLog)(GLuint, GLsizei, GLsizei*, GLchar*);
      GLuint (*glCreateProgram)(void);
      void (*glAttachShader)(GLuint, GLuint);
      void (*glLinkProgram)(GLuint);
      void (*glUseProgram)(GLuint);
      void (*glGetProgramiv)(GLuint, GLenum, GLint*);
      void (*glGetProgramInfoLog)(GLuint, GLsizei, GLsizei*, GLchar*);
      void (*glBindAttribLocation)(GLuint, GLuint, const GLchar*);
      GLint (*glGetUniformLocation)(GLuint, const GLchar *name);
      void (*glUniform1f)(GLint, GLfloat);
      void (*glEnableVertexAttribArray)(GLuint);
      void (*glVertexAttribPointer)(GLuint, GLint, GLenum, GLboolean, GLsizei, const GLvoid*);
      void (*glDrawArrays)(GLenum, GLint, GLsizei);
      void (*glGenTextures)(GLsizei, GLuint*);
      void (*glDeleteTextures)(GLsizei, GLuint*);
      void (*glBindTexture)(GLenum, GLuint);
      void (*glActiveTexture)(GLenum);
      void (*glTexParameteri)(GLenum, GLenum, GLenum);
      void (*glPixelStorei)(GLenum, GLint);
      void (*glTexImage2D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid*);

      PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
   } api;
} gl;

static bool
gles2_load(void)
{
   const char *lib = "libGLESv2.so", *func = NULL;

   if (!(gl.api.handle = dlopen(lib, RTLD_LAZY))) {
      wlc_log(WLC_LOG_WARN, "%s", dlerror());
      return false;
   }

#define load(x) (gl.api.x = dlsym(gl.api.handle, (func = #x)))

   if (!load(glGetString))
      goto function_pointer_exception;
   if (!load(glEnable))
      goto function_pointer_exception;
   if (!load(glClear))
      goto function_pointer_exception;
   if (!load(glClearColor))
      goto function_pointer_exception;
   if (!load(glViewport))
      goto function_pointer_exception;
   if (!load(glBlendFunc))
      goto function_pointer_exception;
   if (!(load(glCreateShader)))
      goto function_pointer_exception;
   if (!(load(glShaderSource)))
      goto function_pointer_exception;
   if (!(load(glCompileShader)))
      goto function_pointer_exception;
   if (!(load(glGetShaderiv)))
      goto function_pointer_exception;
   if (!(load(glGetShaderInfoLog)))
      goto function_pointer_exception;
   if (!(load(glCreateProgram)))
      goto function_pointer_exception;
   if (!(load(glAttachShader)))
      goto function_pointer_exception;
   if (!(load(glLinkProgram)))
      goto function_pointer_exception;
   if (!(load(glUseProgram)))
      goto function_pointer_exception;
   if (!(load(glGetProgramiv)))
      goto function_pointer_exception;
   if (!(load(glGetProgramInfoLog)))
      goto function_pointer_exception;
   if (!(load(glEnableVertexAttribArray)))
      goto function_pointer_exception;
   if (!(load(glBindAttribLocation)))
      goto function_pointer_exception;
   if (!(load(glGetUniformLocation)))
      goto function_pointer_exception;
   if (!(load(glUniform1f)))
      goto function_pointer_exception;
   if (!(load(glVertexAttribPointer)))
      goto function_pointer_exception;
   if (!(load(glDrawArrays)))
      goto function_pointer_exception;
   if (!(load(glGenTextures)))
      goto function_pointer_exception;
   if (!(load(glDeleteTextures)))
      goto function_pointer_exception;
   if (!(load(glBindTexture)))
      goto function_pointer_exception;
   if (!(load(glActiveTexture)))
      goto function_pointer_exception;
   if (!(load(glTexParameteri)))
      goto function_pointer_exception;
   if (!(load(glPixelStorei)))
      goto function_pointer_exception;
   if (!(load(glTexImage2D)))
      goto function_pointer_exception;

   // Needed for EGL hw surfaces
   load(glEGLImageTargetTexture2DOES);

#undef load

   return true;

function_pointer_exception:
   wlc_log(WLC_LOG_WARN, "Could not load function '%s' from '%s'", func, lib);
   return false;
}

static bool
has_extension(const struct ctx *context, const char *extension)
{
   assert(context && extension);

   if (!context->extensions)
      return false;

   size_t len = strlen(extension), pos;
   const char *s = context->extensions;
   while ((pos = strcspn(s, " ")) != 0) {
      size_t next = pos + (s[pos] != 0);

      if (!strncmp(s, extension, len))
         return true;

      s += next;
   }

   return false;
}

static void
set_program(struct ctx *context, const enum program_type type)
{
   assert(context);

   if (&context->programs[type] == context->program)
      return;

   context->program = &context->programs[type];
   gl.api.glUseProgram(context->program->obj);
}

static GLuint
create_shader(const char *source, GLenum shader_type)
{
   assert(source);

   GLuint shader = gl.api.glCreateShader(shader_type);
   assert(shader != 0);

   gl.api.glShaderSource(shader, 1, (const char **)&source, NULL);
   gl.api.glCompileShader(shader);

   GLint status;
   gl.api.glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
   if (!status) {
      GLsizei len;
      char log[1024];
      gl.api.glGetShaderInfoLog(shader, sizeof(log), &len, log);
      wlc_log(WLC_LOG_ERROR, "Compiling %s: %*s\n", (shader_type == GL_VERTEX_SHADER ? "vertex" : "fragment"), len, log);
      abort();
   }

   return shader;
}

static struct ctx*
create_context(void)
{
   static const char *vert_shader_text =
      "precision mediump float;\n"
      "uniform float width;\n"
      "uniform float height;\n"
      "mat4 ortho = mat4("
      "  2.0/width,  0,       0, 0,"
      "     0,   -2.0/height, 0, 0,"
      "     0,       0,      -1, 0,"
      "    -1,       1,       0, 1"
      ");\n"
      "attribute vec4 pos;\n"
      "attribute vec2 uv;\n"
      "varying vec2 v_uv;\n"
      "void main() {\n"
      "  gl_Position = ortho * pos;\n"
      "  v_uv = uv;\n"
      "}\n";

   // TODO: Implement different shaders for different textures
   static const char *frag_shader_rgb_text =
      "precision mediump float;\n"
      "uniform sampler2D texture0;\n"
      "uniform float dim;\n"
      "varying vec2 v_uv;\n"
      "void main() {\n"
      "  gl_FragColor = vec4(texture2D(texture0, v_uv).rgb * dim, 1.0);\n"
      "}\n";

   static const char *frag_shader_rgba_text =
      "precision mediump float;\n"
      "uniform sampler2D texture0;\n"
      "uniform float dim;\n"
      "varying vec2 v_uv;\n"
      "void main() {\n"
      "  vec4 col = texture2D(texture0, v_uv);\n"
      "  gl_FragColor = vec4(col.rgb * dim, col.a);\n"
      "}\n";

   const struct {
      const char *vert;
      const char *frag;
   } map[PROGRAM_LAST] = {
      { vert_shader_text, frag_shader_rgb_text }, // PROGRAM_RGB
      { vert_shader_text, frag_shader_rgba_text }, // PROGRAM_RGBA
   };

   struct ctx *context;
   if (!(context = calloc(1, sizeof(struct ctx))))
      return NULL;

   context->extensions = (const char*)gl.api.glGetString(GL_EXTENSIONS);

   for (int i = 0; i < PROGRAM_LAST; ++i) {
      GLuint vert = create_shader(map[i].vert, GL_VERTEX_SHADER);
      GLuint frag = create_shader(map[i].frag, GL_FRAGMENT_SHADER);
      context->programs[i].obj = gl.api.glCreateProgram();
      gl.api.glAttachShader(context->programs[i].obj, vert);
      gl.api.glAttachShader(context->programs[i].obj, frag);
      gl.api.glLinkProgram(context->programs[i].obj);

      GLint status;
      gl.api.glGetProgramiv(context->programs[i].obj, GL_LINK_STATUS, &status);
      if (!status) {
         GLsizei len;
         char log[1024];
         gl.api.glGetProgramInfoLog(context->programs[i].obj, sizeof(log), &len, log);
         wlc_log(WLC_LOG_ERROR, "Linking:\n%*s\n", len, log);
         abort();
      }

      set_program(context, i);
      gl.api.glBindAttribLocation(context->programs[i].obj, 0, "pos");
      gl.api.glBindAttribLocation(context->programs[i].obj, 1, "uv");

      for (int u = 0; u < UNIFORM_LAST; ++u)
         context->programs[i].uniforms[u] = gl.api.glGetUniformLocation(context->programs[i].obj, uniform_names[u]);
   }

   if (has_extension(context, "GL_OES_EGL_image_external"))
      context->api.glEGLImageTargetTexture2DOES = gl.api.glEGLImageTargetTexture2DOES;

   struct {
      GLenum format;
      GLuint w, h;
      GLenum type;
      void *data;
   } images[TEXTURE_LAST] = {
      { GL_LUMINANCE, 1, 1, GL_UNSIGNED_BYTE, (GLubyte[]){ 0 } }, // TEXTURE_BLACK
      { GL_RGBA, 32, 32, GL_UNSIGNED_BYTE, cursor_rgba },         // TEXTURE_CURSOR
   };

   gl.api.glGenTextures(TEXTURE_LAST, context->textures);

   for (uint32_t i = 0; i < TEXTURE_LAST; ++i) {
      gl.api.glBindTexture(GL_TEXTURE_2D, context->textures[i]);
      gl.api.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
      gl.api.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
      gl.api.glTexImage2D(GL_TEXTURE_2D, 0, images[i].format, images[i].w, images[i].h, 0, images[i].format, images[i].type, images[i].data);
   }

   gl.api.glEnableVertexAttribArray(0);
   gl.api.glEnableVertexAttribArray(1);

   gl.api.glEnable(GL_BLEND);
   gl.api.glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
   gl.api.glClearColor(0.2, 0.2, 0.2, 1);
   return context;
}

static bool
bind(struct ctx *context, struct wlc_output *output)
{
   assert(context && output);

   if (!wlc_context_bind(output->context))
      return false;

   if (!wlc_size_equals(&context->resolution, &output->resolution)) {
      for (int i = 0; i < PROGRAM_LAST; ++i) {
         set_program(context, i);
         gl.api.glUniform1f(context->program->uniforms[UNIFORM_WIDTH], output->resolution.w);
         gl.api.glUniform1f(context->program->uniforms[UNIFORM_HEIGHT], output->resolution.h);
      }

      gl.api.glViewport(0, 0, output->resolution.w, output->resolution.h);
      context->resolution = output->resolution;
   }

   return true;
}

static void
surface_gen_textures(struct wlc_surface *surface, const int num_textures)
{
   assert(surface);

   for (int i = 0; i < num_textures; ++i) {
      if (surface->textures[i])
         continue;

      gl.api.glGenTextures(1, &surface->textures[i]);
      gl.api.glBindTexture(GL_TEXTURE_2D, surface->textures[i]);
      gl.api.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
      gl.api.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
   }
}

static void
surface_flush_textures(struct wlc_surface *surface)
{
   assert(surface);

   for (int i = 0; i < 3; ++i) {
      if (surface->textures[i])
         gl.api.glDeleteTextures(1, &surface->textures[i]);
   }

   memset(surface->textures, 0, sizeof(surface->textures));
}

static void
surface_flush_images(struct wlc_context *context, struct wlc_surface *surface)
{
   assert(surface);

   for (int i = 0; i < 3; ++i) {
      if (surface->images[i])
         wlc_context_destroy_image(context, surface->images[i]);
   }

   memset(surface->images, 0, sizeof(surface->images));
}

static void
surface_destroy(struct ctx *context, struct wlc_surface *surface)
{
   assert(context && surface);

   if (!surface->output)
      return;

   if (!wlc_context_bind(surface->output->context))
      return;

   surface_flush_textures(surface);
   surface_flush_images(surface->output->context, surface);

   if (surface->output->context != context->context)
      wlc_context_bind(context->context);
}

static bool
shm_attach(struct wlc_surface *surface, struct wlc_buffer *buffer, struct wl_shm_buffer *shm_buffer)
{
   assert(surface && buffer && shm_buffer);

   buffer->shm_buffer = shm_buffer;
   buffer->size.w = wl_shm_buffer_get_width(shm_buffer);
   buffer->size.h = wl_shm_buffer_get_height(shm_buffer);

   int pitch;
   GLenum gl_format, gl_pixel_type;
   switch (wl_shm_buffer_get_format(shm_buffer)) {
      case WL_SHM_FORMAT_XRGB8888:
         // gs->shader = &gr->texture_shader_rgbx;
         pitch = wl_shm_buffer_get_stride(shm_buffer) / 4;
         gl_format = GL_BGRA_EXT;
         gl_pixel_type = GL_UNSIGNED_BYTE;
         surface->format = SURFACE_RGBA;
         break;
      case WL_SHM_FORMAT_ARGB8888:
         // gs->shader = &gr->texture_shader_rgba;
         pitch = wl_shm_buffer_get_stride(shm_buffer) / 4;
         gl_format = GL_BGRA_EXT;
         gl_pixel_type = GL_UNSIGNED_BYTE;
         surface->format = SURFACE_RGBA;
         break;
      case WL_SHM_FORMAT_RGB565:
         // gs->shader = &gr->texture_shader_rgbx;
         pitch = wl_shm_buffer_get_stride(shm_buffer) / 2;
         gl_format = GL_RGB;
         gl_pixel_type = GL_UNSIGNED_SHORT_5_6_5;
         surface->format = SURFACE_RGB;
         break;
      default:
         /* unknown shm buffer format */
         return false;
   }

   if (surface->view && surface->view->x11_window)
      surface->format = wlc_x11_window_get_surface_format(surface->view->x11_window);

   surface_gen_textures(surface, 1);
   gl.api.glBindTexture(GL_TEXTURE_2D, surface->textures[0]);
   gl.api.glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, pitch);
   gl.api.glPixelStorei(GL_UNPACK_SKIP_PIXELS_EXT, 0);
   gl.api.glPixelStorei(GL_UNPACK_SKIP_ROWS_EXT, 0);
   wl_shm_buffer_begin_access(buffer->shm_buffer);
   void *data = wl_shm_buffer_get_data(buffer->shm_buffer);
   gl.api.glTexImage2D(GL_TEXTURE_2D, 0, gl_format, pitch, buffer->size.h, 0, gl_format, gl_pixel_type, data);
   wl_shm_buffer_end_access(buffer->shm_buffer);
   return true;
}

static bool
egl_attach(struct ctx *context, struct wlc_surface *surface, struct wlc_buffer *buffer, uint32_t format)
{
   assert(context && surface && buffer);

   buffer->legacy_buffer = (struct wlc_buffer*)buffer->resource;
   wlc_context_query_buffer(context->context, buffer->legacy_buffer, EGL_WIDTH, (EGLint*)&buffer->size.w);
   wlc_context_query_buffer(context->context, buffer->legacy_buffer, EGL_HEIGHT, (EGLint*)&buffer->size.h);
   wlc_context_query_buffer(context->context, buffer->legacy_buffer, EGL_WAYLAND_Y_INVERTED_WL, (EGLint*)&buffer->y_inverted);

   int num_planes;
   GLenum target = GL_TEXTURE_2D;
   switch (format) {
      case EGL_TEXTURE_RGB:
      case EGL_TEXTURE_RGBA:
      default:
         num_planes = 1;
         surface->format = SURFACE_RGBA;
         break;
      case 0x31DA:
         num_planes = 1;
         // gs->target = GL_TEXTURE_EXTERNAL_OES;
         // gs->shader = &gr->texture_shader_egl_external;
         break;
      case EGL_TEXTURE_Y_UV_WL:
         num_planes = 2;
         // gs->shader = &gr->texture_shader_y_uv;
         break;
      case EGL_TEXTURE_Y_U_V_WL:
         num_planes = 3;
         // gs->shader = &gr->texture_shader_y_u_v;
         break;
      case EGL_TEXTURE_Y_XUXV_WL:
         num_planes = 2;
         // gs->shader = &gr->texture_shader_y_xuxv;
         break;
   }

   if (num_planes > 3) {
      wlc_log(WLC_LOG_WARN, "planes > 3 in egl surfaces not supported, nor should be possible");
      return false;
   }

   surface_flush_images(context->context, surface);
   surface_gen_textures(surface, num_planes);

   for (int i = 0; i < num_planes; ++i) {
      EGLint attribs[] = { EGL_WAYLAND_PLANE_WL, i, EGL_NONE };
      if (!(surface->images[i] = wlc_context_create_image(context->context, EGL_WAYLAND_BUFFER_WL, buffer->legacy_buffer, attribs)))
         return false;

      gl.api.glActiveTexture(GL_TEXTURE0 + i);
      gl.api.glBindTexture(target, surface->textures[i]);
      context->api.glEGLImageTargetTexture2DOES(target, surface->images[i]);
   }

   return true;
}

static bool
surface_attach(struct ctx *context, struct wlc_surface *surface, struct wlc_buffer *buffer)
{
   assert(context && surface);

   if (!buffer) {
      surface_destroy(context, surface);
      return true;
   }

   if (!wlc_context_bind(context->context))
      return false;

   int format;
   bool attached = false;
   struct wl_shm_buffer *shm_buffer = wl_shm_buffer_get(buffer->resource);
   if (shm_buffer) {
      attached = shm_attach(surface, buffer, shm_buffer);
   } else if (context->api.glEGLImageTargetTexture2DOES && wlc_context_query_buffer(context->context, (void*)buffer->resource, EGL_TEXTURE_FORMAT, &format)) {
      attached = egl_attach(context, surface, buffer, format);
   } else {
      /* unknown buffer */
      wlc_log(WLC_LOG_WARN, "Unknown buffer");
   }

   return attached;
}

static void
texture_paint(struct ctx *context, GLuint *textures, GLuint nmemb, struct wlc_geometry *geometry, struct paint *settings)
{
   const GLint vertices[8] = {
      geometry->origin.x + geometry->size.w, geometry->origin.y,
      geometry->origin.x,                    geometry->origin.y,
      geometry->origin.x + geometry->size.w, geometry->origin.y + geometry->size.h,
      geometry->origin.x,                    geometry->origin.y + geometry->size.h,
   };

   const GLint coords[8] = {
      1, 0,
      0, 0,
      1, 1,
      0, 1
   };

   set_program(context, settings->program);
   gl.api.glUniform1f(context->program->uniforms[UNIFORM_DIM], settings->dim);

   for (GLuint i = 0; i < nmemb; ++i) {
      if (!textures[i])
         break;

      gl.api.glActiveTexture(GL_TEXTURE0 + i);
      gl.api.glBindTexture(GL_TEXTURE_2D, textures[i]);
   }

   if (settings->filter) {
      gl.api.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
      gl.api.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
   } else {
      gl.api.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
      gl.api.glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   }

   gl.api.glVertexAttribPointer(0, 2, GL_INT, GL_FALSE, 0, vertices);
   gl.api.glVertexAttribPointer(1, 2, GL_INT, GL_FALSE, 0, coords);
   gl.api.glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
}

static void
surface_paint_internal(struct ctx *context, struct wlc_surface *surface, struct wlc_geometry *geometry, struct paint *settings)
{
   assert(context && surface && geometry && settings);

   if (!surface->output || surface->output->context != context->context) {
      wlc_log(WLC_LOG_ERROR, "Trying to paint surface with wrong context or none (%p != %p)", context->context, (surface->output ? surface->output->context : NULL));
      return;
   }

   if (!wlc_size_equals(&surface->size, &geometry->size)) {
      if (wlc_geometry_equals(&settings->visible, geometry)) {
         settings->filter = true;
      } else {
         // black borders are requested
         texture_paint(context, &context->textures[TEXTURE_BLACK], 1, geometry, settings);
         memcpy(geometry, &settings->visible, sizeof(struct wlc_geometry));
      }
   }

   texture_paint(context, surface->textures, 3, geometry, settings);
}

static void
surface_paint(struct ctx *context, struct wlc_surface *surface, struct wlc_origin *pos)
{
   struct paint settings;
   memset(&settings, 0, sizeof(settings));
   settings.dim = 1.0f;
   settings.program = (enum program_type)surface->format;
   surface_paint_internal(context, surface, &(struct wlc_geometry){ { pos->x, pos->y }, { surface->size.w, surface->size.h } }, &settings);
}

static void
view_paint(struct ctx *context, struct wlc_view *view)
{
   assert(context && view);

   struct paint settings;
   memset(&settings, 0, sizeof(settings));
   settings.dim = ((view->commit.state & WLC_BIT_ACTIVATED) || (view->type & WLC_BIT_UNMANAGED) ? 1.0f : 0.5f);
   settings.program = (enum program_type)view->surface->format;

   struct wlc_geometry geometry;
   wlc_view_get_bounds(view, &geometry, &settings.visible);
   surface_paint_internal(context, view->surface, &geometry, &settings);
}

static void
pointer_paint(struct ctx *context, struct wlc_origin *pos)
{
   assert(context);
   struct paint settings;
   memset(&settings, 0, sizeof(settings));
   settings.dim = 1.0;
   settings.program = PROGRAM_RGBA;
   struct wlc_geometry g = { *pos, { 32, 32 } };
   texture_paint(context, &context->textures[TEXTURE_CURSOR], 1, &g, &settings);
}

static void
swap(struct ctx *context)
{
   assert(context);
   wlc_context_swap(context->context);
}

static void
clear(struct ctx *context)
{
   assert(context);
   gl.api.glClear(GL_COLOR_BUFFER_BIT);
}

static void
terminate(struct ctx *context)
{
   assert(context);

   // FIXME: Free gl resources here

   free(context);
}

static void
unload_egl(void)
{
   if (gl.api.handle)
      dlclose(gl.api.handle);

   memset(&gl, 0, sizeof(gl));
}

void*
wlc_gles2_new(struct wlc_context *context, struct wlc_render_api *api)
{
   assert(api);

   if (!gl.api.handle && !gles2_load()) {
      unload_egl();
      return NULL;
   }

   if (!wlc_context_bind(context))
      return NULL;

   struct ctx *gl;
   if (!(gl = create_context()))
      return NULL;

   gl->context = context;

   api->terminate = terminate;
   api->bind = bind;
   api->surface_destroy = surface_destroy;
   api->surface_attach = surface_attach;
   api->view_paint = view_paint;
   api->surface_paint = surface_paint;
   api->pointer_paint = pointer_paint;
   api->clear = clear;
   api->swap = swap;

   wlc_log(WLC_LOG_INFO, "GLES2 renderer initialized");
   return gl;
}

unsigned char cursor_rgba[] = {
  0x19, 0x15, 0x18, 0xff, 0x11, 0x0c, 0x10, 0xff, 0x19, 0x29, 0x19, 0xff,
  0x1c, 0x28, 0x19, 0xff, 0x1c, 0x27, 0x18, 0xff, 0x1f, 0x2e, 0x1c, 0xfe,
  0x20, 0x30, 0x1d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x6a, 0x41, 0xff,
  0xb5, 0xeb, 0xbd, 0xff, 0x9c, 0xc1, 0x67, 0xff, 0x60, 0xbe, 0x67, 0xff,
  0x6a, 0xcb, 0x6f, 0xfe, 0x37, 0x57, 0x27, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x20, 0x30, 0x1d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x24, 0x36, 0x20, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x34, 0x6c, 0x45, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2e, 0x67, 0x43, 0xff, 0x9e, 0xc0, 0x67, 0xff,
  0x5c, 0xb8, 0x66, 0xff, 0x63, 0xbc, 0x67, 0xff, 0x30, 0x49, 0x1f, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x38, 0x5a, 0x2a, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x24, 0x36, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x22, 0x32, 0x1d, 0xff,
  0x35, 0x6f, 0x47, 0xff, 0x34, 0x6c, 0x45, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x34, 0x6c, 0x45, 0x01, 0x00, 0x00, 0x00, 0x00, 0x34, 0x6c, 0x45, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x34, 0x69, 0x46, 0xff, 0x2f, 0x97, 0x31, 0xff, 0x30, 0x96, 0x2e, 0xff,
  0x66, 0xba, 0x69, 0xff, 0x65, 0xc3, 0x6b, 0xfe, 0x36, 0x51, 0x26, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x38, 0x5a, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x23, 0x34, 0x1e, 0xff, 0x30, 0x47, 0x2f, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x34, 0x6c, 0x45, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x6c, 0x48, 0xff,
  0x2d, 0x3d, 0x2c, 0xff, 0x29, 0x3e, 0x29, 0xff, 0x2d, 0x40, 0x2e, 0xff,
  0x29, 0x3e, 0x29, 0xff, 0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x69, 0x46, 0xff,
  0x35, 0xa0, 0x32, 0xfe, 0x34, 0x64, 0x48, 0xff, 0x2f, 0x99, 0x2c, 0xfe,
  0x69, 0xbc, 0x6c, 0xff, 0x31, 0xa2, 0x34, 0xfd, 0x38, 0x56, 0x29, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x46, 0x2e, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01, 0x34, 0x6c, 0x45, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x34, 0x6c, 0x45, 0xff, 0x32, 0x69, 0x48, 0xff,
  0x2b, 0x62, 0x43, 0xff, 0x56, 0x9d, 0x17, 0xfe, 0x51, 0x9d, 0x1a, 0xff,
  0x9d, 0xc3, 0x70, 0xff, 0x4d, 0x9a, 0x15, 0xff, 0xa0, 0xc9, 0x70, 0xff,
  0x21, 0x33, 0x23, 0xff, 0x29, 0x3d, 0x29, 0xfe, 0x2f, 0x45, 0x2d, 0xff,
  0x2f, 0x45, 0x2d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x34, 0x6c, 0x45, 0xfe, 0x34, 0x69, 0x46, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x34, 0x67, 0x47, 0xff, 0x32, 0xa0, 0x32, 0xfd,
  0x39, 0x53, 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x23, 0x35, 0x1f, 0xff, 0x30, 0x46, 0x2e, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x34, 0x6c, 0x45, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x30, 0x66, 0x49, 0xff, 0x57, 0xa0, 0x15, 0xff, 0xba, 0xf1, 0x9d, 0xff,
  0xb1, 0xe8, 0x9d, 0xff, 0x97, 0xbc, 0x67, 0xff, 0xaf, 0xe9, 0x9b, 0xff,
  0x97, 0xbc, 0x67, 0xff, 0xad, 0xe6, 0x99, 0xff, 0xb1, 0xed, 0x98, 0xff,
  0x9b, 0xc7, 0x6b, 0xff, 0x22, 0x35, 0x25, 0xff, 0x2f, 0x45, 0x2d, 0xfe,
  0x2f, 0x45, 0x2d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x34, 0x6c, 0x45, 0xff, 0x00, 0x00, 0x00, 0x00, 0x34, 0x6c, 0x45, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x38, 0x56, 0x29, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x38, 0x5a, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x23, 0x35, 0x1f, 0xff,
  0x2f, 0x43, 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x32, 0x6c, 0x49, 0xff, 0x5f, 0xa8, 0x1a, 0xfe,
  0x2e, 0x63, 0x49, 0xff, 0x29, 0x5f, 0x41, 0xff, 0x58, 0xa1, 0x15, 0xff,
  0x28, 0x5e, 0x47, 0xff, 0x56, 0x9e, 0x14, 0xff, 0x28, 0x5e, 0x47, 0xff,
  0x52, 0x9b, 0x13, 0xff, 0x97, 0xbc, 0x69, 0xff, 0x94, 0xbc, 0x6b, 0xff,
  0x9b, 0xc7, 0x6b, 0xff, 0x22, 0x35, 0x25, 0xff, 0x2f, 0x45, 0x2d, 0xfe,
  0x2f, 0x45, 0x2d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x34, 0x6c, 0x45, 0x01, 0x00, 0x00, 0x00, 0x00, 0x38, 0x5a, 0x2a, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x38, 0x5a, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x24, 0x36, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x34, 0x6e, 0x46, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x32, 0x58, 0x39, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x2e, 0x3e, 0x28, 0xff, 0x2f, 0x66, 0x47, 0xff, 0x50, 0x9a, 0x56, 0xff,
  0x52, 0xa0, 0x59, 0xff, 0x2e, 0x63, 0x45, 0xff, 0x50, 0x9b, 0x56, 0xff,
  0x4c, 0x94, 0x57, 0xff, 0x50, 0x9a, 0x56, 0xff, 0x2f, 0x66, 0x47, 0xff,
  0x4b, 0x98, 0x58, 0xff, 0x4e, 0x95, 0x11, 0xff, 0xb3, 0xeb, 0xa1, 0xff,
  0x9a, 0xc5, 0x68, 0xff, 0x22, 0x35, 0x25, 0xff, 0x2f, 0x45, 0x2d, 0xfe,
  0x2f, 0x45, 0x2d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x34, 0x6c, 0x45, 0x01, 0x00, 0x00, 0x00, 0x00, 0x34, 0x6c, 0x45, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x43, 0x2c, 0xff, 0x31, 0x6c, 0x46, 0xfe,
  0x50, 0x9a, 0x56, 0xff, 0x52, 0xa0, 0x5a, 0xff, 0x1c, 0x30, 0x20, 0xff,
  0x34, 0x6f, 0x48, 0xff, 0x4f, 0x97, 0x55, 0xff, 0x4d, 0x95, 0x54, 0xff,
  0x4f, 0x9a, 0x57, 0xff, 0x2d, 0x3b, 0x28, 0xff, 0x23, 0x64, 0x40, 0xff,
  0x51, 0x9d, 0x5f, 0xff, 0x4c, 0x92, 0x0e, 0xff, 0xb3, 0xeb, 0xa1, 0xff,
  0x9b, 0xc7, 0x6b, 0xff, 0x29, 0x3d, 0x29, 0xff, 0x2f, 0x45, 0x2d, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x34, 0x6c, 0x45, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2d, 0x3e, 0x29, 0xff, 0x51, 0x9d, 0x58, 0xff, 0x4f, 0x9a, 0x56, 0xff,
  0x19, 0x34, 0x24, 0xff, 0xff, 0xca, 0x9c, 0xff, 0x1e, 0x33, 0x21, 0xff,
  0x51, 0x9d, 0x58, 0xff, 0x4f, 0x9a, 0x57, 0xff, 0x51, 0x9f, 0x59, 0xff,
  0x1b, 0x39, 0x26, 0xff, 0xff, 0xc7, 0x9b, 0xff, 0x0e, 0x2a, 0x19, 0xff,
  0x51, 0xa0, 0x61, 0xff, 0x4e, 0x95, 0x11, 0xff, 0x99, 0xc1, 0x6c, 0xff,
  0x26, 0x38, 0x2a, 0xff, 0x2f, 0x45, 0x2d, 0xfe, 0x2f, 0x45, 0x2d, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x43, 0x2c, 0xff, 0x33, 0x6f, 0x47, 0xfe,
  0x4e, 0x97, 0x55, 0xff, 0x4e, 0x9e, 0x5a, 0xff, 0x56, 0x2b, 0x00, 0xff,
  0x4e, 0x2f, 0x05, 0xff, 0x25, 0x6d, 0x44, 0xff, 0x26, 0x66, 0x40, 0xff,
  0x20, 0x35, 0x22, 0xff, 0x1d, 0x38, 0x25, 0xff, 0x5e, 0x39, 0x0c, 0xff,
  0x3f, 0x28, 0x00, 0xff, 0xff, 0xe7, 0xc5, 0xff, 0x0e, 0x28, 0x17, 0xff,
  0x4b, 0x9b, 0x59, 0xff, 0xb8, 0xed, 0xa1, 0xff, 0x56, 0xa2, 0x1a, 0xff,
  0x2c, 0x3f, 0x2e, 0xff, 0x2f, 0x45, 0x2d, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2e, 0x40, 0x2a, 0xff, 0x31, 0x69, 0x45, 0xff, 0x50, 0x9a, 0x56, 0xff,
  0x23, 0x5e, 0x39, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xac, 0x6d, 0x0b, 0xff,
  0xff, 0xcb, 0xac, 0xff, 0xff, 0xc6, 0xa4, 0xff, 0xff, 0xc9, 0xa6, 0xff,
  0xff, 0xce, 0xaf, 0xff, 0xab, 0x6d, 0x0a, 0xff, 0xbd, 0x7f, 0x21, 0xff,
  0x3a, 0x23, 0x00, 0xff, 0xff, 0xdb, 0xb7, 0xff, 0x1b, 0x2c, 0x21, 0xff,
  0x56, 0xa2, 0x1b, 0xff, 0x59, 0xa0, 0x23, 0xff, 0x2d, 0x40, 0x2e, 0xff,
  0x2f, 0x45, 0x2d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x45, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x33, 0x6e, 0x47, 0xff,
  0x52, 0x9f, 0x58, 0xff, 0x50, 0x9d, 0x57, 0xff, 0x26, 0x64, 0x3d, 0xff,
  0xff, 0xf8, 0xdf, 0xff, 0xa3, 0x63, 0x08, 0xff, 0xff, 0xf3, 0xda, 0xff,
  0xff, 0xeb, 0xcf, 0xff, 0xff, 0xeb, 0xcf, 0xff, 0xff, 0xeb, 0xce, 0xff,
  0xff, 0xf8, 0xe3, 0xff, 0xa8, 0x6a, 0x12, 0xff, 0xae, 0x6e, 0x13, 0xff,
  0xff, 0xfd, 0xe7, 0xff, 0x47, 0x9b, 0x52, 0xff, 0x19, 0x2b, 0x24, 0xff,
  0x5f, 0xad, 0x22, 0xff, 0x2c, 0x3d, 0x2c, 0xff, 0x2f, 0x45, 0x2d, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x43, 0x2c, 0xff, 0x2d, 0x40, 0x2b, 0xff,
  0x2e, 0x40, 0x2b, 0xfe, 0x13, 0x31, 0x1b, 0xff, 0xff, 0xf7, 0xe1, 0xff,
  0xf0, 0xb8, 0x0b, 0xff, 0xff, 0xec, 0xd7, 0xff, 0xff, 0xe9, 0xcc, 0xff,
  0xff, 0xe9, 0xcc, 0xff, 0xff, 0xe9, 0xcc, 0xff, 0xff, 0xec, 0xd7, 0xff,
  0xf1, 0xbb, 0x16, 0xff, 0xec, 0xb3, 0x0c, 0xff, 0xff, 0xf9, 0xe8, 0xff,
  0x36, 0x8c, 0x47, 0xff, 0xff, 0xd4, 0xb2, 0xff, 0x1e, 0x31, 0x23, 0xff,
  0x35, 0x74, 0x4a, 0xff, 0x2f, 0x43, 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x3f, 0x28, 0xff,
  0xff, 0xb7, 0x8a, 0xff, 0xff, 0xf6, 0xdc, 0xff, 0xa3, 0x3d, 0x00, 0xff,
  0xff, 0xf2, 0xd7, 0xff, 0xff, 0xe9, 0xcc, 0xff, 0xff, 0xe9, 0xcc, 0xff,
  0xff, 0xe9, 0xcc, 0xff, 0xff, 0xf2, 0xd7, 0xff, 0xa3, 0x3f, 0x00, 0xff,
  0xff, 0xc8, 0xb0, 0xff, 0xff, 0xc3, 0xa2, 0xff, 0x36, 0x8c, 0x47, 0xff,
  0xff, 0xff, 0xf0, 0xff, 0x27, 0x66, 0x3d, 0xff, 0x34, 0x6e, 0x46, 0xff,
  0x2f, 0x43, 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x22, 0x3e, 0x28, 0xff, 0xff, 0xb7, 0x89, 0xff,
  0xfe, 0xf5, 0xdb, 0xff, 0xff, 0xf5, 0xda, 0xff, 0xff, 0xed, 0xd1, 0xff,
  0xff, 0xee, 0xd2, 0xff, 0xff, 0xe8, 0xcb, 0xff, 0xff, 0xee, 0xd2, 0xff,
  0xff, 0xed, 0xd1, 0xff, 0xff, 0xf7, 0xdd, 0xff, 0xfe, 0xf4, 0xda, 0xff,
  0xff, 0xcc, 0xa9, 0xff, 0x44, 0x97, 0x52, 0xff, 0x1e, 0x32, 0x1e, 0xff,
  0x35, 0x6f, 0x47, 0xff, 0x34, 0x6e, 0x46, 0xff, 0x2f, 0x43, 0x2c, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x30, 0x45, 0x2d, 0xff, 0x13, 0x37, 0x22, 0xff, 0xff, 0xb5, 0x87, 0xff,
  0xff, 0xc8, 0xa4, 0xff, 0xff, 0xfa, 0xdd, 0xff, 0xff, 0xf8, 0xda, 0xff,
  0xff, 0xf3, 0xd4, 0xff, 0xff, 0xf8, 0xda, 0xff, 0xff, 0xf8, 0xda, 0xff,
  0xff, 0xfb, 0xdd, 0xff, 0xff, 0xce, 0xa8, 0xff, 0x7b, 0x28, 0x37, 0xff,
  0x4c, 0xa0, 0x58, 0xff, 0x2d, 0x3d, 0x29, 0xff, 0x35, 0x71, 0x48, 0xff,
  0x34, 0x6e, 0x46, 0xff, 0x2e, 0x40, 0x2a, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x45, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xfe,
  0x31, 0x45, 0x2d, 0xff, 0x07, 0x41, 0x27, 0xff, 0xff, 0x27, 0x2c, 0xff,
  0x6f, 0x38, 0x3b, 0xff, 0x7b, 0x32, 0x35, 0xff, 0x7e, 0x35, 0x3e, 0xff,
  0x75, 0x31, 0x36, 0xff, 0x7e, 0x35, 0x3e, 0xff, 0x7f, 0x2e, 0x35, 0xff,
  0x0d, 0x35, 0x1d, 0xff, 0x4d, 0xa0, 0x58, 0xff, 0x44, 0xa1, 0x59, 0xff,
  0x2e, 0x40, 0x2b, 0xff, 0x2e, 0x40, 0x2a, 0xff, 0x34, 0x6e, 0x46, 0xff,
  0x35, 0x71, 0x48, 0xfe, 0x2f, 0x43, 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xff, 0x22, 0x43, 0x2b, 0xff,
  0xff, 0x30, 0x35, 0xff, 0x00, 0x3b, 0x21, 0xff, 0xff, 0x70, 0x72, 0xff,
  0xb5, 0xc0, 0xc6, 0xff, 0x75, 0x93, 0x2e, 0xff, 0xff, 0xd2, 0xb9, 0xff,
  0x6b, 0x88, 0x1f, 0xff, 0xcd, 0xfd, 0xdf, 0xff, 0xff, 0x68, 0x6f, 0xff,
  0x38, 0x9e, 0x54, 0xff, 0xff, 0x25, 0x2f, 0xff, 0x23, 0x47, 0x2d, 0xff,
  0x2f, 0x42, 0x2b, 0xff, 0x35, 0x71, 0x48, 0xff, 0x34, 0x6e, 0x46, 0xff,
  0x2f, 0x43, 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xfe,
  0x2f, 0x42, 0x2b, 0xff, 0x29, 0x75, 0x49, 0xff, 0xff, 0x20, 0x2a, 0xff,
  0xc1, 0xf4, 0x9f, 0xff, 0xff, 0x6a, 0x6f, 0xff, 0x4f, 0x56, 0x5c, 0xff,
  0x83, 0x97, 0x37, 0xff, 0xa1, 0xbd, 0x51, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xf7, 0xff, 0xff, 0xff, 0xff, 0x61, 0x6a, 0xff, 0x38, 0x9e, 0x54, 0xff,
  0xff, 0x2a, 0x32, 0xff, 0x23, 0x46, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xff,
  0x2e, 0x40, 0x2a, 0xff, 0x35, 0x71, 0x48, 0xff, 0x2f, 0x43, 0x2c, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xff, 0x2e, 0x40, 0x2a, 0xff,
  0x36, 0x6e, 0x46, 0xff, 0x0f, 0x78, 0x49, 0xff, 0xff, 0x21, 0x25, 0xff,
  0x4a, 0x62, 0x5e, 0xff, 0x5e, 0x60, 0x5c, 0xff, 0x55, 0x55, 0x58, 0xff,
  0xb3, 0xb1, 0xb6, 0xff, 0xcc, 0xf1, 0xcb, 0xff, 0xd3, 0xf2, 0xd1, 0xff,
  0x3a, 0x92, 0x4b, 0xff, 0x50, 0xa0, 0x55, 0xff, 0x13, 0x42, 0x2a, 0xff,
  0x30, 0x45, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x43, 0x2c, 0xff,
  0x35, 0x71, 0x48, 0xff, 0x2f, 0x43, 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xfe,
  0x2f, 0x42, 0x2b, 0xff, 0x35, 0x71, 0x48, 0xff, 0x1b, 0x74, 0x47, 0xff,
  0xff, 0x29, 0x2c, 0xff, 0x3e, 0x3d, 0x6c, 0xff, 0x8b, 0x65, 0xab, 0xff,
  0x86, 0x61, 0xa6, 0xff, 0xa0, 0x83, 0xbb, 0xff, 0x9b, 0x7e, 0xb5, 0xff,
  0x7f, 0x59, 0x9f, 0xff, 0x84, 0x57, 0xa5, 0xff, 0x49, 0x9e, 0x4e, 0xff,
  0x4c, 0x33, 0x6f, 0xff, 0xff, 0x2f, 0x2f, 0xff, 0x16, 0x48, 0x2c, 0xff,
  0x30, 0x45, 0x2d, 0xff, 0x2f, 0x43, 0x2c, 0xff, 0x35, 0x71, 0x48, 0xff,
  0x2f, 0x43, 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x42, 0x2b, 0xfe,
  0x1c, 0x76, 0x49, 0xff, 0xff, 0x2a, 0x2f, 0xff, 0x71, 0x3b, 0x3c, 0xff,
  0x52, 0x3b, 0x69, 0xff, 0x83, 0x5d, 0xa4, 0xff, 0x82, 0x5c, 0xa7, 0xff,
  0x97, 0x79, 0xb0, 0xff, 0x97, 0x79, 0xb1, 0xff, 0x7d, 0x58, 0x9d, 0xff,
  0x8d, 0x5d, 0xae, 0xff, 0x49, 0x9e, 0x4d, 0xff, 0x50, 0x38, 0x70, 0xff,
  0x72, 0x3b, 0x3c, 0xff, 0xff, 0x2f, 0x32, 0xff, 0x16, 0x48, 0x2c, 0xff,
  0x2f, 0x42, 0x2c, 0xff, 0x35, 0x71, 0x48, 0xff, 0x2f, 0x43, 0x2c, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x45, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x23, 0x46, 0x2d, 0xff, 0xff, 0x29, 0x30, 0xff,
  0x6f, 0x3c, 0x3e, 0xff, 0xff, 0xff, 0xe8, 0xff, 0x1b, 0x3d, 0x4b, 0xff,
  0xd9, 0xfb, 0xda, 0xff, 0xa6, 0xbd, 0x4d, 0xff, 0xfc, 0xff, 0xff, 0xff,
  0xf8, 0xff, 0xfa, 0xff, 0xf4, 0xfc, 0xf2, 0xff, 0x35, 0x8c, 0x3b, 0xff,
  0x41, 0x94, 0x4e, 0xff, 0x84, 0x35, 0x39, 0xff, 0xff, 0xff, 0xe9, 0xff,
  0x6f, 0x3b, 0x3e, 0xff, 0xff, 0x2f, 0x2f, 0xff, 0x22, 0x44, 0x2b, 0xff,
  0x35, 0x71, 0x48, 0xff, 0x2f, 0x43, 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x42, 0x2c, 0xff, 0x23, 0x75, 0x48, 0xff, 0x86, 0x39, 0x3c, 0xff,
  0xff, 0xd8, 0xaf, 0xff, 0x1d, 0x3f, 0x4f, 0xff, 0xdf, 0xfc, 0xdf, 0xff,
  0xa5, 0xba, 0x54, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xfd, 0xff,
  0xec, 0xf4, 0xe9, 0xff, 0xfb, 0xff, 0xf9, 0xff, 0xdd, 0xff, 0xe0, 0xff,
  0x7d, 0x30, 0x34, 0xff, 0xff, 0xd9, 0xb0, 0xff, 0x87, 0x3c, 0x3e, 0xff,
  0x4a, 0x3e, 0x73, 0xff, 0x2d, 0x43, 0x28, 0xff, 0x35, 0x71, 0x48, 0xff,
  0x2f, 0x43, 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0xff,
  0x2f, 0x45, 0x2d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x43, 0x2c, 0xff,
  0x30, 0x75, 0x41, 0xfe, 0x54, 0x3b, 0x75, 0xff, 0x80, 0x2f, 0x31, 0xff,
  0x2b, 0x54, 0x5f, 0xff, 0x17, 0x3b, 0x52, 0xff, 0x88, 0x9d, 0x34, 0xfe,
  0x41, 0x6e, 0x86, 0xff, 0x45, 0x70, 0x81, 0xff, 0x43, 0x77, 0x8a, 0xfe,
  0x19, 0x3d, 0x4c, 0xff, 0x26, 0x48, 0x56, 0xff, 0x20, 0x48, 0x57, 0xfe,
  0x88, 0x3b, 0x3f, 0xff, 0x21, 0x46, 0x26, 0xfe, 0x5d, 0x3d, 0x75, 0xff,
  0x29, 0x43, 0x23, 0xff, 0x35, 0x74, 0x4a, 0xfe, 0x2f, 0x43, 0x2c, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0xff, 0x2f, 0x45, 0x2d, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x38, 0x6b, 0xff,
  0x20, 0x3c, 0x1b, 0xff, 0xdb, 0xff, 0xe5, 0xff, 0x7d, 0x31, 0x36, 0xfe,
  0xff, 0xbd, 0x88, 0xff, 0x7d, 0x39, 0x42, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x81, 0x3a, 0x3d, 0xff, 0xff, 0xbd, 0x89, 0xff,
  0x7d, 0x31, 0x36, 0xfe, 0xd5, 0xf8, 0xd8, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x45, 0x2d, 0xff, 0x2a, 0x46, 0x25, 0xfe, 0x59, 0x3a, 0x71, 0xfe,
  0x2d, 0x43, 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x88, 0x65, 0xa6, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x7e, 0x3b, 0x3d, 0xff, 0xff, 0xff, 0xe2, 0xff,
  0x7e, 0x3a, 0x3d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x7e, 0x3a, 0x3d, 0xff, 0xff, 0xff, 0xe8, 0xfe, 0x76, 0x32, 0x37, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x7f, 0x7a, 0x69, 0x03, 0x00, 0x00, 0x00, 0x00,
  0x24, 0x41, 0x1e, 0xff, 0x8d, 0x67, 0xad, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x2f, 0x45, 0x2d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x2f, 0x45, 0x2d, 0x01, 0x85, 0x63, 0xa3, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x85, 0x63, 0xa3, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x7d, 0x3a, 0x3d, 0xff, 0xff, 0xff, 0xe4, 0xff, 0x7d, 0x3a, 0x3d, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x85, 0x44, 0x45, 0x01, 0x00, 0x00, 0x00, 0x00,
  0xff, 0xae, 0x80, 0xff, 0xff, 0xdc, 0xb4, 0xfe, 0x7d, 0x3c, 0x3f, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x65, 0xaa, 0xff,
  0x00, 0x00, 0x00, 0x00, 0x85, 0x63, 0xa3, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x63, 0xa3, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x85, 0x65, 0xa8, 0xff, 0x8b, 0x40, 0x40, 0xfd,
  0x50, 0x6f, 0x66, 0xff, 0x8a, 0x42, 0x47, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x3b, 0x42, 0xff,
  0x51, 0x72, 0x69, 0xff, 0x8a, 0x42, 0x47, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x85, 0x63, 0xa3, 0xff, 0x00, 0x00, 0x00, 0x00, 0x85, 0x63, 0xa3, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x63, 0xa3, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x5a, 0x3d, 0x0e, 0xff, 0x5c, 0x3a, 0x0b, 0xff,
  0x59, 0x3d, 0x0d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x59, 0x3d, 0x0d, 0xff, 0x5c, 0x3a, 0x0b, 0xff,
  0x59, 0x3d, 0x0d, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x85, 0x63, 0xa3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x3d, 0x10, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x5c, 0x3d, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x3d, 0x10, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x5c, 0x3d, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};
